# Javascript Interview

> ### Disclaimer
> Этот репозиторий написан в первую очередь автором для самообразования и подготовку к собеседованиям. Если Вы найдёте какой-то недочёт в ответах, то можете сообщить об этом.

## Оглавление

* [HTML](#HTML)
* [CSS](#CSS)
* [Javascript](#Javascript)
* [Алгоритмы](#Алгоритмы)

### HTML

- #### Для чего нужен DOCTYPE?
  **DOCTYPE** — это сокращение от **DOCument TYPE** (тип документа). DOCTYPE всегда связан с **DTD** — **Document Type Definition** (определение типа документа).

  DTD определяет как должны быть структурированы документы определенного типа (т.е. тег `button` может содержать в себе тег `span`, но не `div`), в то время как DOCTYPE объявляет, к какому DTD *предположительно* относится документ.

  Для веб-страниц объявление DOCTYPE необходимо. Он используется для того, чтобы сообщить пользовательскому агенту, к какой версии спецификаций HTML принадлежит ваш документ. Как только пользовательский агент распознал правильный DOCTYPE, он запустит режим **no-quirks**, соответствующий этому DOCTYPE, для чтения документа. Если пользовательский агент не распознает правильный DOCTYPE, он активирует режим **quirks**.

  DOCTYPE для стандарта HTML5 определяется как `<!DOCTYPE html>`.

- #### Разные языки
  Когда к серверу делается HTTP-запрос, то браузер пользователя обычно отсылает информацию о предпочитаемом языке в заголовке Accept-Language. Сервер может использовать эту информацию, чтобы вернуть версию документа на подходящем языке, если такая возможность есть. В возвращённом HTML-документе обязательно должен быть указан атрибут lang у тега <html>, к примеру <html lang="en">...</html>.

- #### Для чего нужны data- атрибуты?
  До того, как JavaScript-фреймворки стали популярны, фронтенд-разработчики использовали `data-` атрибуты чтобы хранить дополнительные данные прямо в DOM без хаков вроде нестандартных атрибутов или дополнительных свойств в DOM. Атрибуты этого семейства предназначены для хранения частных данных пользователя, для которых не существует более подходящих атрибутов или элементов на странице или в приложении.

  На сегодняшний день использование data-атрибутов не поощряется. Одной из причин является то, что пользователь может модифицировать данные в атрибуте, используя инспектор кода в браузере. Данные лучше хранить в самом JavaScript и обновлять DOM при помощи связывания данных через библиотеку или фреймворк.
  
- #### Из каких блоков состоит HTML5?
  - Семантика. Позволяет более точно описать из чего состоит контент.
  - Связанность. Позволяет общаться с сервером новыми и инновационными способами.
  - Офлайн и хранилище. Позволяют страницам хранить данные локально на клиентской стороне и более эффективно работать в офлайне.
  - Мультимедиа. Ставит создание видео и аудио на первое место в вебе.
  - 2D/3D-графика и эффекты. Позволяет расширить возможности презентации.
  - Производительность и интеграция. Обеспечивает большую скорость оптимизации и лучшее использование аппаратных средств.
  - Доступ к устройствам. Позволяет взаимодействовать с различными устройствами ввода и вывода.
  - Стилизация. Позволяет создавать более сложные темы оформления.

- #### cookie, sessionStorage и localStorage
  Все вышеупомянутые технологии являются механизмами хранения типа ключ-значение на клиентской стороне. Они могут хранить данные только как строки.

  |  | cookie | localStorage | sessionStorage |
  | --- | --- | --- | --- |
  | Инициатор | Клиент или сервер. Сервер может использовать заголовок Set-Cookie | Клиент | Клиент |
  | Срок хранения | Устанавливается вручную | Всегда | До закрытия вкладки |
  | Хранение между сессиями | Зависит от установки срока хранения | Да | Нет |
  | Отправка на сервер с каждым HTTP-запросом | автоматически, с помощью заголовка Cookie | Нет | Нет |
  | Емкость (на один домен) | 4 КБ | 5 МБ | 5 МБ |
  | Доступность | В любом окне | В любом окне | В той же вкладке |

- #### <script>, <script async> и <script defer>
  - `<script>` - отрисовка HTML блокируется, скрипт извлекается и выполняется немедленно, отрисовка HTML возобновляется после окончания выполнения скрипта.
  - `<script async>` - скрипт будет получен и обработан параллельно с отрисовкой HTML, его выполнение закончится как только это будет возможно (обычно до того, как закончилась отрисовка HTML). Используйте `async` тогда, когда скрипт не зависит от других скриптов на странице, например для аналитики.
  - `<script defer>` - скрипт будет получен параллельно с отрисовкой HTML, его выполнение произойдет после того, как вся страница будет загружена. Если таких скриптов несколько, то каждый из них будет исполнятся в том порядке, в котором они расположены в документе. Если скрипту нужен полностью распарсеный DOM, то атрибут `defer` обеспечит уверенность в том, что на момент отработки скрипта весь HTML отрисован. Нет особой разницы со скриптами, расположенными перед тегом `<body>`. Отложенный скрипт не должен содержать `document.write`.

  Примечание: Атрибуты `async` и `defer` игнорируются, если у тега `<script>` нет атрибута `src`.

- #### Размещение <link> внутри <head>
  Размещение <link> внутри тега <head> необходимо при создании оптимизированного веб-сайта. Когда страница загружается впервые, HTML и CSS анализируются одновременно; HTML создает DOM (объектную модель документа), а CSS создает CSSOM (объектную модель CSS). И то, и другое необходимо для создания визуальных элементов на веб-сайте, что позволяет быстро определить время «первого значимого рисования». Этот прогрессивный рендеринг является категорией оптимизации сайтов, которые измеряются в их показателях эффективности. Размещение таблиц стилей в нижней части документа - это то, что препятствует прогрессивной загрузке страницы во многих браузерах. Некоторые браузеры блокируют рендеринг, чтобы избежать перерисовки элементов страницы, если ее стили изменятся. Все это время пользователь будет пялиться на пустую белую страницу. В других случаях может возникать мерцание нестилизованного содержимого (FOUC), на котором может отображаться веб-страница без применения стилей.

- #### Размещение <script> прямо перед </body>
  Теги `<script>` блокируют отрисовку HTML на то время, пока они скачиваются и исполняются. Размещение скриптов внизу позволяет сперва распарсить и показать пользователю весь HTML.

  Исключением является случай, когда в вашем скрипте содержится `document.write()`. Но на сегодняшний день его использование не считается хорошей практикой. К тому же, расположение скриптов внизу разметки означает, что браузер не может начать их скачивать до тех пор, пока не отрисован весь документ. Единственным рабочим способом, при котором `<script>` будет расположен внутри `<head>`, является добавление атрибута defer.

- #### Что такое прогрессивный рендеринг
  Прогрессивный рендеринг — это название технологий, используемых для ускорения отрисовки страниц (в частности, для уменьшения времени загрузки), чтобы показать пользователю контент как можно скорее.

  До того, как широкополосный интернет распространился повсеместно, прогрессивный рендеринг встречался довольно часто. Но этот подход по прежнему полезен в современной разработке, поскольку все более популярным (и ненадежным) становится мобильный доступ в интернет.

  Примеры подобных технологий:

  - Ленивая загрузка изображений. Изображения на странице не загружаются все разом. JavaScript подгрузит изображения тогда, когда пользователь доскроллит до той части страницы, на которой они расположены.
  - Приоритизация видимого контента. Только минимум CSS, контента, скриптов, необходимых для отрисовки той части страницы, которую пользователь увидит первой. Вы можете использовать отложенные скрипты или слушать события `DOMContentLoaded` или `load`, чтобы загрузить остальные ресурсы и контент.
  - Асинхронные фрагменты HTML. Отправка в браузер частей HTML-страницы, созданной на бэкенде

- #### Для чего используется атрибут srcset в теге изображения?
  Вы должны использовать атрибут `srcset`, когда хотите показывать пользователям разные изображения в зависимости от их ширины дисплея их устройств - предоставление изображений более высокого качества устройствам с retina-дисплеями улучшает работу пользователя, в то время как предоставление изображений с низким разрешением на устройства с низким разрешением повышает производительность и уменьшает объём передаваемых данных (поскольку нет видимой разницы с большими изображениями). Например: `<img srcset="small.jpg 500w, medium.jpg 1000w, large.jpg 2000w" src="..." alt="">` указывает браузеру отображать малое, среднее или большое изображение в зависимости от разрешения дисплея пользователя. Первое значение - это имя изображения, а второе - ширина изображения в пикселях. Для ширины устройства 320px выполняются следующие расчеты:

  - 500 / 320 = 1.5625
  - 1000 / 320 = 3.125
  - 2000 / 320 = 6.25

  Если у клиента стандартное разрешение 1x, то 1.5625 является ближайшим коэффициентом, и `500w` соответствующее `small.jpg` будет отображено в браузере.

  Если же разрешение retina (2x), браузер будет использовать ближайшее разрешение выше минимального. Это означает, что он не выберет 500w (1.5625), потому что оно больше 1 и изображение может выглядеть плохо. Браузер затем выберет изображение с результирующим соотношением ближе к 2, то есть 1000w (3.125).

  `srcset` решает проблему, когда вы хотите показывать файлы изображений меньшего размера для устройств с узким экраном, поскольку они не нуждаются в больших изображениях, как на настольных дисплеях, - а также, при желании, вы можете показывать изображения с различным разрешением для экранов с высокой/низкой плотностью пикселей.

  Вы должны использовать атрибут `srcset`, когда хотите показывать пользователям разные изображения в зависимости от их ширины дисплея их устройств - предоставление изображений более высокого качества устройствам с retina-дисплеями улучшает работу пользователя, в то время как предоставление изображений с низким разрешением на устройства с низким разрешением повышает производительность и уменьшает объём передаваемых данных (поскольку нет видимой разницы с большими изображениями). Например: `<img srcset="small.jpg 500w, medium.jpg 1000w, large.jpg 2000w" src="..." alt="">` указывает браузеру отображать малое, среднее или большое изображение в зависимости от разрешения дисплея пользователя. Первое значение - это имя изображения, а второе - ширина изображения в пикселях. Для ширины устройства 320px выполняются следующие расчеты:

  - 500 / 320 = 1.5625
  - 1000 / 320 = 3.125
  - 2000 / 320 = 6.25

  Если у клиента стандартное разрешение 1x, то 1.5625 является ближайшим коэффициентом, и `500w` соответствующее `small.jpg` будет отображено в браузере.

  Если же разрешение retina (2x), браузер будет использовать ближайшее разрешение выше минимального. Это означает, что он не выберет 500w (1.5625), потому что оно больше 1 и изображение может выглядеть плохо. Браузер затем выберет изображение с результирующим соотношением ближе к 2, то есть 1000w (3.125).

  `srcset` решает проблему, когда вы хотите показывать файлы изображений меньшего размера для устройств с узким экраном, поскольку они не нуждаются в больших изображениях, как на настольных дисплеях, - а также, при желании, вы можете показывать изображения с различным разрешением для экранов с высокой/низкой плотностью пикселей.

- #### Языки HTML-шаблонизации?
  Pug (ранее известный как Jade), ERB, Slim, Handlebars, Jinja, Liquid и это только некоторые из них. По моему мнению, все они более или менее одинаковые и предоставляют одинаковые возможности экранирования контента и полезных фильтров для работы с отображаемыми данными. Большинство шаблонизаторов позволяют вводить собственные фильтры, если вам необходима дополнительная обработка контента перед его отображением.


### CSS

- #### Что такое специфичность CSS-селектора и как она работает?
  Браузер определяет, какие стили показывать для элемента, в зависимости от специфичности CSS-правил. Мы предполагаем, что браузер уже определил правила, которые соответствуют конкретному элементу. Среди соответствующих правил специфичность, состоящая из четырех значений, разделенных запятыми, `a, b, c, d`, рассчитывается для каждого правила на основе следующего:

  1. `a` - это использование встроенных стилей. Если объявление свойства является встроенным стилем элемента, `a` равно 1, иначе 0.
  2. `b` - это количество селекторов ID.
  3. `c` - это количество селекторов классов, атрибутов и псевдо-классов.
  4. `d` - это количество селекторов тегов и псевдо-элементов.

  Результативная специфичность не является оценкой, а матрицей значений, которые можно сравнивать по столбцам. При сравнении селекторов, чтобы определить, у кого наивысшая специфичность, смотрите слева направо и сравнивайте наивысшее значение в каждом столбце. Таким образом, значение в столбце `b` будет переопределять значения в столбцах `c` и `d`, независимо от того, каковы они могут быть. Так, специфичность `0,1,0,0` будет больше, чем `0,0,10,10`.

  В случае равной специфичности счет идет за последним правилом. Если вы написали одно и то же правило в вашем стилевом листе (независимо от того, внутренний он или внешний) дважды, то нижнее правило в вашем стилевом листе ближе к элементу, который должен быть стилизован, оно считается более специфичным и поэтому будет применено.

  Я бы писал CSS-правила с низкой специфичностью, чтобы их можно было легко переопределить при необходимости. При написании кода библиотеки интерфейсных компонентов CSS важно, чтобы они имели низкую специфичность, чтобы пользователи библиотеки могли переопределить их, не используя слишком сложные CSS-правила только ради увеличения специфичности или прибегая к `!important`.

- #### В чем разница между "сбросом" и "нормализацией" CSS? Что бы вы выбрали и почему?
  - **Сброс** - Сброс предназначен для удаления всех стандартных стилей браузера для элементов. Например, `margin`, `padding`, `font-size` для всех элементов будут сброшены. Вам придется заново объявить стили для распространенных типографских элементов.
  - **Нормализация** - Нормализация сохраняет полезные стили по умолчанию, а не "снимает" все стили. Она также исправляет ошибки, связанные с распространенными зависимостями браузеров.

  Я бы выбрал сброс, если у меня очень индивидуальный или нетрадиционный дизайн сайта, и мне нужно сделать много собственных стилей и не нужно сохранять стили по умолчанию.

- #### Опишите флоаты и их работу
  Float - это свойство позиционирования CSS. Плавающие элементы остаются частью потока страницы и влияют на позиционирование других элементов (например, текст обтекает плавающие элементы), в отличие от элементов `position: absolute`, которые удаляются из потока страницы.

  Свойство CSS `clear` можно использовать для позиционирования под `левыми`, `правыми` или `обоими` плавающими элементами.

  Если родительский элемент не содержит ничего, кроме плавающих элементов, его высота уменьшится до нуля. Это можно исправить, очистив float после плавающих элементов в контейнере, но до закрытия контейнера.

  Хак `.clearfix` использует умный CSS [псевдоселектор](https://www.frontendinterviewhandbook.com/ru/css-questions#describe-pseudo-elements-and-discuss-what-they-are-used-for) (`::after`) для очистки поплавков. Вместо того чтобы устанавливать переполнение для родителя, вы применяете к нему дополнительный класс `clearfix`. Затем примените этот CSS:

  ``css
  .clearfix::after {
  content: ' ';
  видимость: скрытый;
  display: block;
  высота: 0;
  clear: both;
  }

  ```

  В качестве альтернативы задайте родительскому элементу свойство `overflow: auto` или `overflow: hidden`, которое создаст новый контекст форматирования блока внутри дочерних элементов, и он будет расширяться, чтобы содержать свои дочерние элементы.
  ```

### Javascript

- #### Типы данных
  Стандарт ECMAScript определяет 8 типов:

  - 6 типов данных являющихся примитивами:
      - [Undefined](https://developer.mozilla.org/ru/docs/Glossary/Undefined) (Неопределённый тип) : `typeof instance === "undefined"`
      - [Boolean](https://developer.mozilla.org/ru/docs/Glossary/Boolean) (Булев, Логический тип) : `typeof instance === "boolean"`
      - [Number](https://developer.mozilla.org/ru/docs/Glossary/Number) (Число) : `typeof instance === "number"`
      - [String](https://developer.mozilla.org/ru/docs/Glossary/String) (Строка) : `typeof instance === "string"`
      - [BigInt](https://developer.mozilla.org/ru/docs/Glossary/BigInt) : `typeof instance === "bigint"`
      - [Symbol (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Symbol) (в ECMAScript 6) : `typeof instance === "symbol"`
  - [Null](https://developer.mozilla.org/ru/docs/Glossary/Null) (Null тип ) : `typeof instance === "object"`. Специальный примитив, используемый не только для данных но и в качестве указателя на финальную точку в [Цепочке Прототипов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain);
  - [Object](https://developer.mozilla.org/ru/docs/Glossary/Object) (Объект) : `typeof instance === "object"`. Простая структура, используемая не только для хранения данных, но и для создания других структур, где любая структура создаётся с использованием ключевого слова `[new](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/new)`: new [Object](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object), new [Array](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array), new [Map (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map), new [Set](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Set), new [WeakMap](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap), new [WeakSet](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakSet), new [Date](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date) и множество других структур;

  И здесь нам необходимо сделать предостережение относительно использования оператора `typeof` для определения типа структур, т.к. все структуры будут возвращать `"object"` при его использовании, так как назначение `typeof` — проверка типа данных, но не структур. Если проверить тип структуры всё же необходимо, то в этом случае желательно использовать оператор [instanceof](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof), так как именно он отвечает на вопрос о том, какой конструктор был использован для создания структуры.

  Стоит отметить два особых случая работы оператора `typeof`: возврат `"object"` для значения `null` и `"function"` для функций: первое принято считать ошибкой языка, сохраненной ради обратной совместимости, второе является условностью, удобной для проверки на принадлежность значения категории функций, где функция - это особый, "вызываемый", объект.

- #### 3начение примитивного типа
  **Примитив** (значение примитивного типа, примитивный тип данных) это данные, которые не являются [объектом](https://developer.mozilla.org/ru/docs/Glossary/Object) и не имеют [методов](https://developer.mozilla.org/ru/docs/Glossary/Method). В [JavaScript](https://developer.mozilla.org/ru/docs/Glossary/JavaScript) 7 простых типов данных: [string](https://developer.mozilla.org/ru/docs/Glossary/String), [number](https://developer.mozilla.org/ru/docs/Glossary/Number), [boolean](https://developer.mozilla.org/ru/docs/Glossary/Boolean), [null](https://developer.mozilla.org/ru/docs/Glossary/Null), [undefined](https://developer.mozilla.org/ru/docs/Glossary/Undefined), [symbol (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Symbol) (новое в [ECMAScript](https://developer.mozilla.org/ru/docs/Glossary/ECMAScript) 2015), [bigint](https://developer.mozilla.org/ru/docs/Glossary/BigInt).

  Все **примитивы** неизменяемы (immutable), то есть они не могут быть изменены. Важно не путать сам примитив с переменной, которой присвоено значение примитивного типа. Переменной может быть переприсвоено новое значение, но существующее значение примитивного типа не может быть изменено подобно объектам, массивам и функциям.

  За исключением `null` и `undefined`, все примитивные значения имеют объектный аналог, который оборачивает значение примитивного типа:

  - `[String](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String)` для string примитива.
  - `[Number](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number)` для number примитива.
  - `[BigInt](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/BigInt)` для bigint примитива.
  - `[Boolean](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Boolean)` для boolean примитива.
  - `[Symbol](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Symbol)` для symbol примитива.

  Метод `[valueOf()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf)` типа обёртки возвращает значение примитивного типа.

- #### null, undefined и не объявленные переменные
  **Необъявленные** переменные создаются, когда вы присваиваете значение идентификатору, который не был ранее создан при помощи `var`,`let` или `const`. Необъявленные переменные будут определены глобально, вне текущей области видимости. В строгом режиме, будет ошибка `ReferenceError`, когда вы попытаетесь назначить значение необъявленной переменной. Необъявленные переменные плохи так же, как и глобальные переменные. Избегайте их любой ценой! Чтобы проверить на их наличие, оберните код в блок `try`/`catch`.

  ```jsx
  function foo() {
    x = 1; *// ReferenceError в строгом режиме*
  }

  **foo();
  console.log(x);
  *// 1*
  ```

  Переменная `undefined` - это переменная, которая была объявлена, но ей не было присвоено значение. Ее тип `undefined`. Если переменной присвоить функцию, которая не возвращает никакого значения, то переменная также будет иметь значение `undefined`. Чтобы проверить это, сравните, используя оператор строгого равенства (`===`) или `typeof`, который вернет строку `'undefined'`. Обратите внимание, что вам не следует использовать оператор абстрактного сравнения для проверки, так как он также вернет `true`, если значение равно `null`.

  ```jsx
  var foo;
  console.log(foo); // undefined
  console.log(foo === undefined); // true
  console.log(typeof foo === 'undefined'); // true

  console.log(foo == null); // true. Неправильно, не используйте это для проверки!

  function bar() {}
  var baz = bar();
  console.log(baz); // undefined
  ```

  Переменной со значением `null` было явно присвоено значение `null`. Она отличается от `undefined` тем, что она была назначена явно. Чтобы проверить на `null`, просто сравните, используя оператор строгого равенства. Обратите внимание, что, как и выше, вы не должны использовать оператор абстрактного равенства (`==`) для проверки, так как он также вернет `true`, если значение равно `undefined`.

  ```jsx
  var foo = null;
  console.log(foo === null); // true
  console.log(typeof foo === 'object'); // true

  console.log(foo == undefined); 
  // true. Неправильно, не используйте это для проверки!
  ```
- #### Оператор void
  Оператор `void` исполняет заданное выражение, а затем возвращает `undefined`.

  ```jsx
  const output = void 1;
  console.log(output);
  // Expected output: undefined

  void console.log('expression evaluated');
  // Expected output: "expression evaluated"

  void (function iife() {
    console.log('iife is executed');
  })();
  // Expected output: "iife is executed"

  void function test() {
    console.log('test function executed');
  };

  try {
    test();
  } catch (e) {
    console.log('test function is not defined');
    // Expected output: "test function is not defined"
  }
  ```
- #### IIFE - немедленно вызываемое функциональное выражение
  **Объясните, почему это не является IIFE: `function foo(){ }();`**

  IIFE расшифровывается как Immediately Invoked Function Expression - немедленно вызываемое функциональное выражение. Синтаксический анализатор JavaScript читает `function foo(){ } ();` как `function foo(){ }` и `();`, где первое выражение - это *объявление функции*, а второе (пара скобок) - попытка вызова функции, но так как имя не указано, он выдает ошибку `Uncaught SyntaxError: Unexpected token`.

  Вот два способа исправить это, которые заключаются добавление дополнительных скобок: `(function foo(){ })()` и `(function foo(){ }())`. Выражения, начинающиеся с `function`, считаются *объявлениями функций*. Оборачивая эту функцию внутри `()`, она становится *функциональным выражением*, которое затем может быть выполнено с последующим `()`. Подобные функции не отображаются в глобальной области видимости, и вы можете даже не указывать им имя, если вы не будете на них ссылаться.

  Вы также можете использовать оператор `void` - `void function foo(){ }()`. К сожалению, с таким подходом есть одна проблема. Выполнение данного выражения всегда возвращает `undefined`, поэтому, если ваше IIFE возвращает что-либо, вы не можете его использовать. Пример:

  ```jsx
  const foo = void (function bar() {
    return 'foo';
  })();
  console.log(foo); // undefined
  ```
- #### Что такое замыкание и как/для чего его используют?
  Замыкание - это комбинация функции и лексического окружения, в которой эта функция была объявлена. Слово "лексический" относится к тому факту, что лексическая область видимости использует место, где переменная объявлена в исходном коде, чтобы определить, где эта переменная доступна. Замыкания - это функции, которые имеют доступ к переменным внешней (замыкающей) функции - цепочке областей видимости даже после того, как внешняя функция вернулась.
- #### Каррирование

- #### Как работает прототипное наследование
  Все объекты в JavaScript имеют свойство `__proto__`,  которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки прототипов. Такое поведение имитирует классическое наследование, но на самом деле это скорее [делегирование, чем наследование](https://davidwalsh.name/javascript-objects).

  ОО-подобный механизм свойств объектов в JavaScript обозначается [[Прототип]], который является внутренней характеристикой любого объекта, называемой его прототип-цепочкой - специальной ссылкой на другой объект. Это что-то вроде механизма области видимости, поскольку связь [[Prototype]] описывает, на какой альтернативный объект следует ссылаться, если вы запрашиваете свойство или метод вашего объекта, которого не существует.

  **Другими словами, вы указываете объект для делегирования поведения, если это поведение не определено для данного объекта.**

  ```jsx
  let animal = {
    eats: true,
    walk() {
      alert("Animal walk");
    }
  };

  let rabbit = {
    jumps: true,
    __proto__: animal
  };

  let longEar = {
    earLength: 10,
    __proto__: rabbit
  };

  // walk взят из цепочки прототипов
  longEar.walk(); // Animal walk
  alert(longEar.jumps); // true (из rabbit)
  ```

  Свойство `__proto__` — исторически обусловленный геттер/сеттер для `[[Prototype]]`

  Это распространённая ошибка начинающих разработчиков – не знать разницы между этими двумя понятиями.

  Обратите внимание, что `__proto__` — *не то же самое*, что внутреннее свойство `[[Prototype]]`. Это геттер/сеттер для `[[Prototype]]`.

  Свойство `__proto__` немного устарело, оно существует по 
  историческим причинам. Современный JavaScript предполагает, что мы 
  должны использовать функции `Object.getPrototypeOf/Object.setPrototypeOf` вместо того, чтобы получать/устанавливать прототип. 

  По спецификации `__proto__` должен поддерживаться только 
  браузерами, но по факту все среды, включая серверную, поддерживают его. 

  https://learn.javascript.ru/prototype-inheritance
- #### Как работает this
  Говоря максимально простым языком, значение `this` зависит от того, как вызывается функция.

  ## Случаи

  Если ключевое слово `new` используется при вызове функции, `this` внутри функции является совершенно новым объектом.

  ```jsx
  function ConstructorExample() {
      console.log(this);
      this.value = 10;
      console.log(this);
  }
  new ConstructorExample();
  // -> {}
  // -> { value: 10 }
  ```

  Если для вызова/создания функции используются `apply`, `call` или `bind`, то `this` внутри функции - это объект, который передается в качестве аргумента.

  ```jsx
  function fn() {
      console.log(this);
  }
  var obj = {
      value: 5
  };
  var boundFn = fn.bind(obj);
  boundFn();     // -> { value: 5 }
  fn.call(obj);  // -> { value: 5 }
  fn.apply(obj); // -> { value: 5 }
  ```

  Если функция вызывается как метод, например, `obj.method()`, то `this` - это объект, к которому принадлежит функция.

  ```jsx
  var obj = {
      value: 5,
      printThis: function() {
          console.log(this);
      }
  };
  obj.printThis(); // -> { value: 5, printThis: ƒ }
  ```

  Если функция вызывается без контекста, то есть она вызывается без условий, описанных в пунктах выше, то `this` является глобальным объектом. В браузере это объект `window`. В строгом режиме (`'use strict'`), `this` будет `undefined` вместо глобального объекта.

  ```jsx
  function fn() {
      console.log(this);
  }
  // If called in browser:
  fn(); // -> Window {stop: ƒ, open: ƒ, alert: ƒ, ...}
  ```

  Заметьте, что это правило аналогично правилу 3 - разница в том, что функция, не объявленная как метод, автоматически становится свойством глобального объекта window. Таким образом, это неявное обращение к методу. Когда мы вызываем `fn(),` это интерпретируется как `window.fn()`, так что это window.
  `console.log(fn === window.fn); // -> true`

  Если применяются несколько из вышеперечисленных правил, то правило, которое выше выигрывает и устанавливает значение `this`.

  Если функция является стрелочной функцией, то она игнорирует все вышеописанные правила и получает значение `this` из лексического окружения во время ее создания.

  ```jsx
  const obj = {
      value: 'abc',
      createArrowFn: function() {
          return () => console.log(this);
      }
  };
  const arrowFn = obj.createArrowFn();
  arrowFn(); // -> { value: 'abc', createArrowFn: ƒ }
  ```

  Библиотеки иногда намеренно привязывают значение this внутри своих функций. this привязывается к наиболее полезному значению для использования в функции. jQuery, например, привязывает this к элементу DOM, вызывающему событие, в обратном вызове этого события. Если библиотека имеет неожиданное значение this, которое не соответствует правилам, проверьте ее документацию. Скорее всего, оно привязывается с помощью bind.
- #### Делегирование событий

  Делегирование событий - это приём, заключающийся в добавлении 
  обработчиков событий к родительскому элементу, а не к дочерним 
  элементам. Обработчик будет срабатывать всякий раз, когда событие будет 
  запущено на дочерних элементах благодаря всплытию событий в DOM. 
  Преимущества этого приёма:

  - Экономит объем используемой памяти, т.к. для родительского элемента требуется только один обработчик.
  - Не нужно привязывать или убирать обработчики при добавлении и удалении элементов.


  ```html
  <ul id="parent-list">
    <li id="post-1">Item 1</li>
    <li id="post-2">Item 2</li>
    <li id="post-3">Item 3</li>
    <li id="post-4">Item 4</li>
    <li id="post-5">Item 5</li>
    <li id="post-6">Item 6</li>
  </ul>
  ```

  ```jsx
  // Get the element, add a click listener...
  document.getElementById("parent-list").addEventListener("click", function(e) {
    // e.target is the clicked element!
    // If it was a list item
    if(e.target && e.target.nodeName == "LI") {
      // List item found!  Output the ID!
      console.log("List item ", e.target.id.replace("post-", ""), " was clicked!");
    }
  });
  ```
- #### Function.length
  Свойство **`length`** определяет количество аргументов, ожидаемых функцией.

  ```jsx
  console.log(Function.length); /* 1 */

  console.log(function () {}.length); /* 0 */
  console.log(function (a) {}.length); /* 1 */
  console.log(function (a, b) {}.length); /* 2 и так далее */
  console.log(
    function (...args) {}.length,
  ); /* 0, остаточные параметры не считаются */
  ```

### Алгоритмы

- #### Сортировка пузырьком
  Сортировка пузырьком — самый примитивный и базовый алгоритм сортировки. Он является основой для некоторых других алгоритмов. Этот алгоритм является стабильным. Сортировка пузырьком перебирает весь массив элементов, сравнивая два соседних элемента друг с другом и меняя их местами в соответствии с условиями. Элементы с большим значением опускаются вниз массива, а элементы с наименьшим значением поднимаются вверх, подобно пузырькам газа.

  Сложность алгоритма: O(n^2), где `n` — количество элементов массива. Так как мы запускаем вложенный цикл, сложность алгоритма равна O(n^2)

  Шаги реализации:

  1. Запускаем цикл `i` по массиву.
  2. Запускаем внутренний цикл `j`, который идёт от `0` до `arr.length - i`. Это ускоряет алгоритм, так как он не проходит по уже отсортированным элементам.
  3. Во внутреннем цикле проверяем соседние элементы и меняем их местами, если сосед слева больше соседа справа.

  ```jsx
  const bubbleSort = (arr) => {
    for (let i = 0; i < arr.length; i++) {
      for (let j = 0; j < arr.length - i; j++) {
        if (arr[j] > arr[j + 1]) {
          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // Меняем значения переменных
        }
      }
    }
  };
  ```

- #### Сортировка слиянием
  **Одна из самых стабильных сортировок**

  Часто в разработке есть задача отсортировать данные за один проход или даже по мере их появления. Классическое решение — использовать [быструю сортировку](https://thecode.media/qsort/), то есть сортировку вокруг опорного элемента. Но если неверно выбрать этот опорный элемент, скорость сортировки резко возрастёт.

  Основной принцип сортировки слиянием такой: делим массив пополам, каждый из них сортируем слиянием и потом соединяем оба массива. Каждый разделённый массив тоже нарезаем на два подмассива до тех пор, пока в каждом не окажется по одному элементу.

  Сложность алгоритма: O(n*log(n))

  1. Исходный массив: [4 2 5 1].
  2. Делим пополам: [4 2] ←→ [5 1] (у нас появилось два новых массива, значит, к ним применяем тоже сортировку слиянием).
  3. Делим пополам **первый массив**: [4] ←→ [2].
  4. Раз в каждом по одному элементу, то сортируем и склеиваем в один: [2 4].
  5. Делим пополам **второй массив**: [5] ←→ [1].
  6. Раз в каждом по одному элементу — сортируем и склеиваем в один: [1 5].
  7. К нам вернулись два отсортированных подмассива, а значит, нам нужно их отсортировать и склеить в один.
  8. Сравниваем первые элементы: 1 и 2. Единица меньше двух, значит, в итоговый массив записываем 1, и у нас остаются два массива: [2 4] и [5].
  9. Сравниваем первые элементы: 2 и 5. Двойка меньше пяти, значит, в итоговый массив записываем 2, и у нас остаются два массива: [4] и [5].
  10. Точно так же сравниваем первые элементы до тех пор, пока в обоих массивах не исчезнут все элементы. Как только это произойдёт — массив отсортирован.

  ```jsx
  // слияние массивов с одновременной сортировкой
  // на вход подаются уже отсортированные левая и правая части
  function merge(left, right) {
      // сюда будем складывать результат
      let arr = []
      // пока в каждой части есть хотя бы один элемент — выполняем цикл
      while (left.length && right.length) {
          // смотрим на наименьший элемент из тех, что стоят в начале обоих массивов
          if (left[0] < right[0]) {
              // если слева был элемент меньше —
              // забираем его оттуда и отправляем в массив с результатом
              arr.push(left.shift())
          } else {
              // в противном случае забираем элемент из правой части
              arr.push(right.shift())
          }
      }
      // выводим результат слияния отсортированных массивов
      console.log('Результат: ' + arr);

      // возвращаем отсортированный массив и добавляем к нему в конец отсортированный остаток от какой-либо части, если её так и не обработали в цикле
      return [ ...arr, ...left, ...right ]
  }

  // делим массивы пополам до тех пор, пока в них не останется элементов
  function mergeSort(array) {
    // находим середину
    const half = array.length / 2

    // если в нашем массиве и так меньше двух элементов — возвращаем его
    if(array.length < 2){
      return array
    }

    // делим массив на две части и левую отправляем в новый массив
    const left = array.splice(0, half)
    // выводим промежуточный результат
    console.log('Слева:' + left);
    console.log('Справа:' + array);
    // запускаем рекурсию и отдаём ей правую и левую части массива
    return merge(mergeSort(left),mergeSort(array))
  }

  // исходный массив
  array = [3, 5, 1, 6, 9, 8, 2];
  console.log(mergeSort(array));
  ```

- #### Сортировка подсчётом

  Сортировка подсчётом лучше всего работает при таких условиях:

  - массив очень большой — значений много;
  - эти значения лежат в известном нам диапазоне (например, это диапазон работы какого-то датчика);
  - диапазон намного меньше, чем размер массива, то есть единицы данных могут повторяться.

  Сложность алгоритма: O(nk)

  Главная идея алгоритма — посчитать, сколько раз встречается каждый элемент в массиве, а потом заполнить исходный массив результатами этого подсчёта. Для этого нам нужен вспомогательный массив, где мы будем хранить результаты подсчёта. Даже если нам надо отсортировать миллион чисел, мы всё равно знаем диапазон этих чисел заранее, например, от 1 до 100. Это значит, что во вспомогательном массиве будет не миллион элементов, а сто.

  В общем виде всё работает так:

  1. Мы создаём вспомогательный массив и на старте заполняем его нулями.
  2. Проходим по всему исходному массиву и смотрим очередное значение в ячейке.
  3. Берём содержимое этой ячейки и увеличиваем на единицу значение вспомогательного массива под этим номером. Например, если мы встретили число 5, то увеличиваем на единицу пятый элемент вспомогательного массива. Если встретили 13 — тринадцатый.
  4. После цикла во вспомогательном массиве у нас хранятся данные, сколько раз встречается каждый элемент.
  5. Теперь мы проходим по вспомогательному массиву, и если в очередной ячейке лежит что-то больше нуля, то мы в исходный массив столько же раз отправляем номер этой ячейки. Например, в первой ячейке вспомогательного массива лежит число 7. Это значит, что в исходный массив мы отправляем единицу 7 раз подряд.

  ```jsx
  // сортировка подсчётом
  let countingSort = (arr, min, max) => {
    // начинаем с минимального значения диапазона
      let i = min,
        // вспомогательная переменная для цикла
          j = 0,
          // получаем длину массива
          len = arr.length,
          // вспомогательный массив, где будем хранить результаты подсчёта
          count = [];

      // сначала заполняем нулями массив с результатом подсчёта
      for (i; i <= max; i++) {
          count[i] = 0;
      }

      // потом проходим по всему исходному массиву
      for (i = 0; i < len; i++) {
        // и увеличиваем на единичку ячейки под тем же номером в массиве с результатом подсчёта
          count[arr[i]] += 1;
      }

      // а затем проходим по массиву с результатом
      for (i = min; i <= max; i++) {
        // пока в очередной ячейке значение больше нуля
          while (count[i] > 0) {
            // добавляем номер ячейки в исходный массив
              arr[j] = i;
              // переходим к следующему элементу в исходном массиве
              j++;
              // уменьшаем на единицу содержимое ячейки в массиве с подсчётом
              count[i]--;
          }
      }
      // как всё сделали — возвращаем отсортированный массив
      return arr;
  };

  // исходный массив
  let arr = [0,3,5,2,4,5,2,3];
  // сортируем его
  countingSort(arr,0,5);
  // и выводим результат
  console.log(arr)
  ```

